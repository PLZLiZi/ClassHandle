/*
 * This source file was generated by the Gradle 'init' task
 */
package plz.lizi.classhandle;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.instrument.ClassDefinition;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.rmi.RemoteException;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import com.sun.tools.attach.VirtualMachine;
import sun.misc.Unsafe;

public class ClassHandle {
	private static Unsafe UNSAFE = getUnsafe();
	private static Lookup LOOKUP = getLookup();
	private static Instrumentation INST;
	private Class<?> klass;
	private byte[] bytes;
	private String handleName;
	private String className;
	private ClassLoader loader;
	private static Map<String, Class<?>> hiddenClassMap = new HashMap<>();

	public static void init(boolean agentMode) {
		if (agentMode) {
			try {
				Field f = Class.forName("sun.tools.attach.HotSpotVirtualMachine").getDeclaredField("ALLOW_ATTACH_SELF");
				UNSAFE.putObject(UNSAFE.staticFieldBase(f), UNSAFE.staticFieldOffset(f), true);
				VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));
				vm.loadAgent(getJarPath());
				vm.detach();
			} catch (Exception e) {
				try {
					Files.copy(ClassHandle.class.getResourceAsStream("/plz/lizi/classhandle/" + dll()), Path.of(System.getProperty("user.dir") + "\\" + dll()), StandardCopyOption.REPLACE_EXISTING);
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				System.load(System.getProperty("user.dir") + "\\" + dll());
				INST = makeInstrumentation();
			}
		} else {
			try {
				Files.copy(ClassHandle.class.getResourceAsStream("/plz/lizi/classhandle/" + dll()), Path.of(System.getProperty("user.dir") + "\\" + dll()), StandardCopyOption.REPLACE_EXISTING);
				System.load(System.getProperty("user.dir") + "\\" + dll());
				INST = makeInstrumentation();
			} catch (Exception e) {
				throw new RuntimeException("Can't init INST");
			}
		}
	}

	private static String dll() {
		String arch = System.getProperty("os.arch");
		if (arch.contains("64")) {
			return "classhandle-x64.dll";
		} else if (arch.contains("86") || arch.contains("32")) {
			return "classhandle-x86.dll";
		} else {
			throw new RuntimeException("System not support -> OS:" + System.getProperty("os.name") + ", JVM:" + System.getProperty("sun.arch.data.model") + ", OS_ARCH:" + System.getProperty("os.arch"));
		}
	}

	private static native Instrumentation makeInstrumentation();

	private static Unsafe getUnsafe() {
		if (UNSAFE != null)
			return UNSAFE;
		Unsafe instance = null;
		try {
			Constructor<Unsafe> c = Unsafe.class.getDeclaredConstructor();
			c.setAccessible(true);
			instance = c.newInstance();
		} catch (Throwable var3) {
			var3.printStackTrace();
		}
		return instance;
	}

	private static MethodHandles.Lookup getLookup() {
		try {
			return (MethodHandles.Lookup) UNSAFE.getObjectVolatile(UNSAFE.staticFieldBase(MethodHandles.Lookup.class.getDeclaredField("IMPL_LOOKUP")), UNSAFE.staticFieldOffset(MethodHandles.Lookup.class.getDeclaredField("IMPL_LOOKUP")));
		} catch (Exception e) {
			try {
				Constructor<MethodHandles.Lookup> c = MethodHandles.Lookup.class.getDeclaredConstructor();
				c.setAccessible(true);
				return c.newInstance();
			} catch (Throwable var3) {
				var3.printStackTrace();
			}
		}
		return null;
	}

	public ClassHandle(Class<?> klass) {
		this.klass = klass;
		this.handleName = klass.getName();
		this.className = handleName;
		this.loader = klass.getClassLoader();
	}

	public ClassHandle(String name, ClassLoader loader, Class<?> lookup) {
		try {
			boolean has = false;
			for (Class<?> c : new ArrayList<>((ArrayList<Class<?>>) LOOKUP.findVarHandle(ClassLoader.class, "classes", ArrayList.class).get(loader))) {
				if (c.getName().equals(name)) {
					has = true;
				}
			}
			if (loader == null)
				loader = lookup.getClassLoader();
			if (has) {
				this.klass = Class.forName(name, false, loader);
				this.handleName = klass.getName();
				this.className = klass.getName();
				this.loader = klass.getClassLoader();
				this.bytes = getClassBytes(klass);
			} else {
				this.handleName = name;
				this.className = name;
				this.loader = loader;
				this.bytes = getClassBytes(getJarPath(lookup), name);
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public ClassHandle(String name, ClassLoader loader, byte[] bytes) {
		try {
			boolean has = false;
			for (Class<?> c : new ArrayList<>((ArrayList<Class<?>>) LOOKUP.findVarHandle(ClassLoader.class, "classes", ArrayList.class).get(loader))) {
				if (c.getName().equals(name))
					has = true;
			}
			if (has) {
				this.klass = Class.forName(name, false, loader);
				this.handleName = klass.getName();
				this.className = klass.getName();
				this.loader = klass.getClassLoader();
				this.bytes = getClassBytes(klass);
			} else {
				this.handleName = name;
				this.className = name;
				this.loader = loader;
				this.bytes = bytes;
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public void redefine(byte[] newBuf) throws Throwable {
		INST.redefineClasses(new ClassDefinition(klass, newBuf));
	}

	public void retransform(byte[] newBuf) throws Throwable {
		ClassFileTransformer transformer = new ClassFileTransformer() {
			@Override
			public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
				if (className.equals(ClassHandle.this.className)) {
					return newBuf;
				}
				return classfileBuffer;
			}

			@Override
			public byte[] transform(Module module, ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
				if (className.equals(ClassHandle.this.className)) {
					return newBuf;
				}
				return classfileBuffer;
			}
		};
		INST.addTransformer(transformer, true);
		INST.retransformClasses(klass);
		INST.removeTransformer(transformer);
	}

	public static Class<?> findHidden(String name) {
		return hiddenClassMap.get(name);
	}

	public Class<?> define() throws Throwable {
		if (klass != null) {
			return klass;
		}
		klass = (Class<?>) LOOKUP.findVirtual(ClassLoader.class, "defineClass", MethodType.methodType(Class.class, String.class, byte[].class, int.class, int.class, ProtectionDomain.class)).invoke(loader, className, bytes, 0, bytes.length, null);
		setClassName(className);
		return klass;
	}

	public Class<?> defineHidden() throws Throwable {
		if (klass != null) {
			return klass;
		}
		if (hiddenClassMap.containsKey(handleName) && hiddenClassMap.get(handleName) != null) {
			return hiddenClassMap.get(handleName);
		}
		int flags = 6;
		if (loader == null || loader == ClassLoader.getPlatformClassLoader()) {
			flags |= 8;
		}
		klass = (Class<?>) LOOKUP.findStatic(ClassLoader.class, "defineClass0", MethodType.methodType(Class.class, ClassLoader.class, Class.class, String.class, byte[].class, int.class, int.class, ProtectionDomain.class, boolean.class, int.class, Object.class)).invoke(loader, ClassHandle.class, className, bytes, 0, bytes.length, null, true, flags, null);
		setClassName(className);
		hiddenClassMap.put(handleName, klass);
		return klass;
	}

	public ClassLoader getLoader() {
		return loader;
	}

	public ClassHandle setLoader(ClassLoader loader) {
		this.loader = loader;
		return this;
	}

	public byte[] geetBytes() {
		return bytes;
	}

	public ClassHandle setBytes(byte[] bytes) {
		this.bytes = bytes;
		return this;
	}

	public ClassHandle setClassName(String newName) throws Throwable {
		className = newName;
		if (klass != null)
			LOOKUP.findSetter(Class.class, "name", String.class).invoke(klass, className);
		return this;
	}

	public ClassHandle setHandleName(String newName) {
		this.handleName = newName;
		return this;
	}

	public String getHandleName() {
		return handleName;
	}

	public String getClassName() {
		return className;
	}

	public Class<?> toClass() {
		return klass;
	}

	private static String realClassName(Class<?> klass) {
		return klass.getName().split("\\$\\$")[0].split("\\$")[0].trim();
	}

	@SuppressWarnings("unchecked")
	private static <T> T copy(T original) throws Throwable {
		if (original == null) {
			return null;
		}
		if (original.getClass().isArray()) {
			int length = java.lang.reflect.Array.getLength(original);
			Object newArray = java.lang.reflect.Array.newInstance(original.getClass().getComponentType(), length);
			System.arraycopy(original, 0, newArray, 0, length);
			return (T) newArray;
		}
		T copy = (T) UNSAFE.allocateInstance(original.getClass());
		copyFields(original, copy);
		return copy;
	}

	private static void copyFields(Object old, Object next) {
		Map<String, Object> oldFieldMap = new HashMap<>();
		for (Field field : old.getClass().getDeclaredFields()) {
			try {
				if (!Modifier.isStatic(field.getModifiers())) {
					oldFieldMap.put(field.getName(), LOOKUP.unreflectGetter(field).invoke(old));
				}
			} catch (Throwable e) {
			}
		}
		for (Field field : next.getClass().getDeclaredFields()) {
			if (oldFieldMap.containsKey(field.getName())) {
				Object obj = oldFieldMap.get(field.getName());
				try {
					LOOKUP.unreflectSetter(field).invoke(next, obj);
				} catch (Throwable e) {
				}
			}
		}
	}

	private static byte[] readAllBytes(InputStream is) throws IOException {
		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
		byte[] data = new byte[4096];
		int bytesRead;
		while ((bytesRead = is.read(data, 0, data.length)) != -1) {
			buffer.write(data, 0, bytesRead);
		}
		buffer.flush();
		return buffer.toByteArray();
	}

	private static byte[] getClassBytes(Class<?> clazz) throws Exception {
		InputStream is = clazz.getResourceAsStream("/" + realClassName(clazz).replace('.', '/') + ".class");
		byte[] dat = new byte[is.available()];
		is.read(dat);
		is.close();
		return dat;
	}

	private static byte[] getClassBytes(String jarPath, String className) throws Exception {
		try (JarFile jarFile = new JarFile(jarPath)) {
			String classPath = className.replace('.', '/') + ".class";
			JarEntry entry = jarFile.getJarEntry(classPath);
			if (entry == null) {
				jarFile.close();
				throw new ClassNotFoundException("Class not found in JAR: " + className);
			}
			try (InputStream is = jarFile.getInputStream(entry)) {
				return readAllBytes(is);
			}
		}
	}

	private static String getJarPath() {
		try {
			ProtectionDomain protectionDomain = ClassHandle.class.getProtectionDomain();
			CodeSource codeSource = protectionDomain.getCodeSource();
			if (codeSource != null) {
				URL jarUrl = codeSource.getLocation();
				return new File(jarUrl.getPath()).getAbsolutePath().split("%")[0];
			}
		} catch (Throwable e) {
			e.printStackTrace();
		}
		return "";
	}

	private static String getJarPath(Class<?> cls) {
		try {
			CodeSource codeSource = cls.getProtectionDomain().getCodeSource();
			if (codeSource != null) {
				return new File(codeSource.getLocation().getPath()).getAbsolutePath().split("%")[0];
			}
		} catch (Throwable e) {
			e.printStackTrace();
		}
		return "";
	}

	private static String readFile(String filePath) throws Throwable {
		Path path = Paths.get(filePath);
		File file = path.toFile();
		if (!file.exists()) {
			throw new RemoteException("null");
		}
		byte[] encoded = readAllBytes(new FileInputStream(file));
		return new String(encoded, StandardCharsets.UTF_8);
	}

	private static void writeFile(String filePath, String content) throws Exception {
		File file = new File(filePath);
		if (!file.exists()) {
			file.createNewFile();
		}
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
			writer.write(content);
		}
	}

	private static String getStackTrace() {
		StringBuilder builder = new StringBuilder();
		for (StackTraceElement stackTrace : Thread.currentThread().getStackTrace()) {
			builder.append(stackTrace);
			builder.append("\n");
		}
		return builder.toString();
	}

	private static void accessModule(Module moudle) {
		try {
			LOOKUP.findStatic(Module.class, "addReads0", MethodType.methodType(void.class, Module.class, Module.class)).invoke(moudle, null);
		} catch (Throwable e) {
		}
	}
}
